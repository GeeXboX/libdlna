/*******************************************************************************
 *
 * Copyright (c) 2000-2003 Intel Corporation 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met: 
 *
 * * Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * * Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * * Neither name of Intel Corporation nor the names of its contributors 
 * may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************/

#ifndef UPNP_H
#define UPNP_H

/** @name The API */

/*! @{ */


#if defined MYLIB_LARGEFILE_SENSITIVE && _FILE_OFFSET_BITS+0 != 64
	#if defined __GNUC__
		#warning libdlna requires largefile mode - use AC_SYS_LARGEFILE
	#else
		#error  libdlna requires largefile mode - use AC_SYS_LARGEFILE
	#endif
#endif 


#include <stdio.h>
#include <sys/param.h>
#if (defined(BSD) && BSD >= 199306)
	#include <time.h>
#endif
#include "ixml.h"
#include "upnpconfig.h"


#ifdef WIN32
	#ifndef DLNA_STATIC_LIB
		#ifdef LIBDLNA_EXPORTS
			/* set up declspec for dll export to make functions visible to library users */
			#define EXPORT_SPEC __declspec(dllexport)
		#else
			#define EXPORT_SPEC __declspec(dllimport)
		#endif
	#else
		#define EXPORT_SPEC
	#endif
	#ifdef DLNA_USE_MSVCPP
		/* define some things the M$ VC++ doesn't know */
		#define DLNA_INLINE
		typedef __int64 int64_t;
		#define PRId64 "I64d"
		#define PRIzu "lu"
	#endif
	#ifdef DLNA_USE_BCBPP
		/* define some things Borland Builder doesn't know */
		#define DLNA_INLINE inline
		typedef __int64 int64_t;
#warning The Borland C compiler is probably broken on PRId64, please someone provide a proper fix here
		#define PRId64 "I64d"
		#define PRIzu "zu"
	#endif
#else
	#define EXPORT_SPEC
	#define DLNA_INLINE inline
	/* Invented this macro so that we can live a little longer with MSVC lack of C99. */
	#define PRIzu "zu"
#endif

/*
 * Defining this macro here gives some interesting information about unused
 * functions in the code. Of course, this should never go uncommented on a
 * release.
 */
/*#define inline*/


#ifndef WIN32
	#define dlnaCloseSocket close
#else
	#define dlnaCloseSocket closesocket
	#define fseeko fseek
#endif
#define DLNA_SOCKETERROR -1
#define DLNA_INVALID_SOCKET -1
#ifndef WIN32
	#define SOCKET int
#endif


#ifndef WIN32
	#include <netinet/in.h>
#else
	#include <winsock2.h>
	#include <time.h>
#endif


#include <sys/types.h>


#define NUM_HANDLE 200
#define LINE_SIZE  180
#define NAME_SIZE  256
#define MNFT_NAME_SIZE  64
#define MODL_NAME_SIZE  32
#define SERL_NUMR_SIZE  64
#define MODL_DESC_SIZE  64
#define DLNA_INFINITE -1
#define DLNA_USING_CHUNKED			-3
#define DLNA_UNTIL_CLOSE			-4


/** @name Error codes 
 *  The functions in the SDK API can return a variety of error 
 *  codes to describe problems encountered during execution.  This section 
 *  lists the error codes and provides a brief description of what each error 
 *  code means.  Refer to the documentation for each function for a 
 *  description of what an error code means in that context.
 */
/*! @{ */

/** @name DLNA_E_SUCCESS [0]
 *  {\tt DLNA_E_SUCCESS} signifies that the operation completed successfully.
 *  For asynchronous functions, this only means that the packet generated by 
 *  the operation was successfully transmitted on the network.  The result of 
 *  the entire operation comes as part of the callback for that operation.
 */
/*! @{ */
#define DLNA_E_SUCCESS          0
/*! @} */

/** @name DLNA_E_INVALID_HANDLE [-100]
 *  {\tt DLNA_E_INVALID_HANDLE} signifies that the handle passed to a 
 *  function is not a recognized as a valid handle.
 */
/*! @{ */
#define DLNA_E_INVALID_HANDLE   -100
/*! @} */

/** @name DLNA_E_INVALID_PARAM [-101]
 *  {\tt DLNA_E_INVALID_PARAM} signifies that one or more of the parameters 
 *  passed to the function is not valid.  Refer to the documentation for each 
 *  function for more information on the valid ranges of the parameters.
 */
/*! @{ */
#define DLNA_E_INVALID_PARAM    -101
/*! @} */

/** @name DLNA_E_OUTOF_HANDLE [-102]
 *  {\tt DLNA_E_OUTOF_HANDLE} signifies that the SDK does not have any
 *  more space for additional handles.  The SDK allocates space for only 
 *  a few handles in order to conserve memory.
 */
/*! @{ */
#define DLNA_E_OUTOF_HANDLE     -102
/*! @} */

#define DLNA_E_OUTOF_CONTEXT    -103

/** @name DLNA_E_OUTOF_MEMORY [-104]
 *  {\tt DLNA_E_OUTOF_MEMORY} signifies that not enough resources are 
 *  currently available to complete the operation.  Most operations require 
 *  some free memory in order to complete their work.
 */
/*! @{ */
#define DLNA_E_OUTOF_MEMORY     -104
/*! @} */

/** @name DLNA_E_INIT [-105]
 *  {\tt DLNA_E_INIT} signifies that the SDK has already been 
 *  initialized.  The SDK needs to be initialied only once per process.
 *  Any additional initialization attempts simply return this error with
 *  no other ill effects.
 */
/*! @{ */
#define DLNA_E_INIT             -105
/*! @} */

#define DLNA_E_BUFFER_TOO_SMALL -106

/** @name DLNA_E_INVALID_DESC [-107]
 *  {\tt DLNA_E_INVALID_DESC} signifies that the description document passed
 *  to {\bf dlnaRegisterRootDevice} or {\bf dlnaRegisterRootDevice2} is an 
 *  invalid description document.  
 */
/*! @{ */
#define DLNA_E_INVALID_DESC     -107
/*! @} */

/** @name DLNA_E_INVALID_URL [-108]
 *  {\tt DLNA_E_INVALID_URL} signifies that a URL passed into the function
 *  is invalid.  The actual cause is function specific, but in general, the
 *  URL itself might be malformed (e.g. have invalid characters in it) or
 *  the host might be unreachable.
 */
/*! @{ */
#define DLNA_E_INVALID_URL      -108
/*! @} */

#define DLNA_E_INVALID_SID      -109
#define DLNA_E_INVALID_DEVICE   -110

/** @name DLNA_E_INVALID_SERVICE [-111]
 *  {\tt DLNA_E_INVALID_SERVICE} is returned only by {\bf dlnaNotify}, 
 *  {\bf dlnaNotifyExt}, {\bf dlnaAcceptSubscription}, and 
 *  {\bf dlnaAcceptSubscriptionExt} to signify that the device ID/service
 *  ID pair does not refer to a valid service.
 */
/*! @{ */
#define DLNA_E_INVALID_SERVICE  -111
/*! @} */

/** @name DLNA_E_BAD_RESPONSE [-113]
 *  {\tt DLNA_E_BAD_RESPONSE} signifies that the response received from the 
 *  remote side of a connection is not correct for the protocol.  This applies
 *  to the GENA, SOAP, and HTTP protocols.
 */
/*! @{ */
#define DLNA_E_BAD_RESPONSE     -113
/*! @} */

#define DLNA_E_BAD_REQUEST      -114

/** @name DLNA_E_INVALID_ACTION [-115]
 *  {\tt DLNA_E_INVALID_ACTION} signifies that the SOAP action message is 
 *  invalid.  This can be because the DOM document passed to the function was
 *  malformed or the action message is not correct for the given action.
 */
/*! @{ */
#define DLNA_E_INVALID_ACTION   -115
/*! @} */

/** @name DLNA_E_FINISH [-116]
 *  {\tt DLNA_E_FINISH} signifies that {\bf dlnaInit} has not been called, or
 *  that {\bf dlnaFinish} has already been called.  None of the API functions 
 *  operate until {\bf dlnaInit} successfully completes.
 */
/*! @{ */
#define DLNA_E_FINISH           -116
/*! @} */

/** @name DLNA_E_INIT_FAILED [-117]
 *  {\tt DLNA_E_INIT_FAILED} signifies that {\bf dlnaInit} cannot complete.  
 *  The typical reason is failure to allocate sufficient resources.
 */
/*! @{ */
#define DLNA_E_INIT_FAILED      -117
/*! @} */

/** @name DLNA_E_URL_TOO_BIG [-118]
 *  {\tt DLNA_E_URL_TOO_BIG} signifies that the URL passed into a function 
 *  is too long.  The SDK limits URLs to 180 characters in length.  
 */
#define DLNA_E_URL_TOO_BIG      -118

/** @name DLNA_E_BAD_HTTPMSG [-119]
 *  {\tt DLNA_E_BAD_HTTPMSG} signifies that the HTTP message contains invalid
 *  message headers.  The error always refers to the HTTP message header 
 *  received from the remote host.  The main areas where this occurs are in
 *  SOAP control messages (e.g. {\bf dlnaSendAction}), GENA subscription
 *  message (e.g. {\bf dlnaSubscribe}), GENA event notifications (e.g. {\bf
 *  dlnaNotify}), and HTTP transfers (e.g. {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_BAD_HTTPMSG      -119
/*! @} */

/** @name DLNA_E_ALREADY_REGISTERED [-120]
 *  {\tt DLNA_E_ALREADY_REGISTERED} signifies that a client or a device is
 *  already registered.  The SDK currently has a limit of one registered 
 *  client and one registered device per process.
 */
/*! @{ */
#define DLNA_E_ALREADY_REGISTERED -120
/*! @} */

/** @name DLNA_E_NETWORK_ERROR [-200]
 *  {\tt DLNA_E_NETWORK_ERROR} signifies that a network error occurred.  It 
 *  is the generic error code for network problems that are not covered under 
 *  one of the more specific error codes.  The typical meaning is the SDK 
 *  failed to read the local IP address or had problems configuring one of
 *  the sockets.
 */
/*! @{ */
#define DLNA_E_NETWORK_ERROR    -200
/*! @} */

/** @name DLNA_E_SOCKET_WRITE [-201]
 *  {\tt DLNA_E_SOCKET_WRITE} signifies an error writing to a socket.  This
 *  occurs in any function that makes network connections, such 
 *  as discovery (e.g. {\bf dlnaSearchAsync} or {\bf dlnaSendAdvertisement}), 
 *  control (e.g. {\bf dlnaSendAction}), eventing (e.g. {\bf dlnaNotify}), 
 *  and HTTP functions (e.g. {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_SOCKET_WRITE     -201
/*! @} */

/** @name DLNA_E_SOCKET_READ [-202]
 *  {\tt DLNA_E_SOCKET_READ} signifies an error reading from a socket.  This
 *  occurs in any function that makes network connections, such 
 *  as discovery (e.g. {\bf dlnaSearchAsync} or {\bf dlnaSendAdvertisement}), 
 *  control (e.g. {\bf dlnaSendAction}), eventing (e.g. {\bf dlnaNotify}), 
 *  and HTTP functions (e.g. {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_SOCKET_READ      -202
/*! @} */

/** @name DLNA_E_SOCKET_BIND [-203]
 *  {\tt DLNA_E_SOCKET_BIND} signifies that the SDK had a problem binding
 *  a socket to a network interface.  This occurs in any function that makes 
 *  network connections, such as discovery (e.g. {\bf dlnaSearchAsync} or 
 *  {\bf dlnaSendAdvertisement}), control (e.g. {\bf dlnaSendAction}), eventing 
 *  (e.g. {\bf dlnaNotify}), and HTTP functions (e.g. 
 *  {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_SOCKET_BIND      -203
/*! @} */

/** @name DLNA_E_SOCKET_CONNECT [-204]
 *  {\tt DLNA_E_SOCKET_CONNECT} signifies that the SDK had a problem
 *  connecting to a remote host.  This occurs in any function that makes 
 *  network connections, such as discovery (e.g. {\bf dlnaSearchAsync} or 
 *  {\bf dlnaSendAdvertisement}), control (e.g. {\bf dlnaSendAction}), eventing 
 *  (e.g. {\bf dlnaNotify}), and HTTP functions (e.g. 
 *  {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_SOCKET_CONNECT   -204
/*! @} */

/** @name DLNA_E_OUTOF_SOCKET [-205]
 *  {\tt DLNA_E_OUTOF_SOCKET} signifies that the SDK cannot create any
 *  more sockets.  This occurs in any function that makes 
 *  network connections, such as discovery (e.g. {\bf dlnaSearchAsync} or 
 *  {\bf dlnaSendAdvertisement}), control (e.g. {\bf dlnaSendAction}), eventing 
 *  (e.g. {\bf dlnaNotify}), and HTTP functions (e.g. 
 *  {\bf dlnaDownloadXmlDoc}).
 */
/*! @{ */
#define DLNA_E_OUTOF_SOCKET     -205
/*! @} */

/** @name DLNA_E_LISTEN [-206]
 *  {\tt DLNA_E_LISTEN} signifies that the SDK had a problem setting the
 *  socket to listen for incoming connections.  This error only happens during
 *  initialization (i.e. {\bf dlnaInit}).
 */
/*! @{ */
#define DLNA_E_LISTEN           -206
/*! @} */

/** @name DLNA_E_TIMEDOUT [-207]
 *  {\tt DLNA_E_TIMEDOUT} signifies that too much time elapsed before the
 *  required number of bytes were sent or received over a socket.  This error
 *  can be returned by any function that performs network operations.
 */
/*! @{ */
#define DLNA_E_TIMEDOUT         -207
/*! @} */

/** @name DLNA_E_SOCKET_ERROR [-208]
 *  {\tt DLNA_E_SOCKET_ERROR} is the generic socket error code for
 *  conditions not covered by other error codes.  This error can be returned
 *  by any function that performs network operations.
 */
/*! @{ */
#define DLNA_E_SOCKET_ERROR	    -208
/*! @} */

#define DLNA_E_FILE_WRITE_ERROR -209

/** @name DLNA_E_CANCELED [-210]
 *  {\tt DLNA_E_CANCELED} signifies that the operation was canceled. This
 *  error can be returned by any function that allows for external
 *  cancelation.
 */
/*! @{ */
#define DLNA_E_CANCELED         -210
/*! @} */

#define DLNA_E_EVENT_PROTOCOL         -300

/** @name DLNA_E_SUBSCRIBE_UNACCEPTED [-301]
 *  {\tt DLNA_E_SUBSCRIBE_UNACCEPTED} signifies that a subscription
 *  request was rejected from the remote side.  
 */
/*! @{ */
#define DLNA_E_SUBSCRIBE_UNACCEPTED   -301
/*! @} */

/** @name DLNA_E_UNSUBSCRIBE_UNACCAPTED [-302]
 *  {\tt DLNA_E_UNSUBSCRIBE_UNACCEPTED} signifies that an unsubscribe
 *  request was rejected from the remote side.
 */
/*! @{ */
#define DLNA_E_UNSUBSCRIBE_UNACCEPTED -302
/*! @} */

/** @name DLNA_E_NOTIFY_UNACCEPTED [-303]
 *  {\tt DLNA_E_NOTIFY_UNACCEPTED} signifies that the remote host did not
 *  accept the notify sent from the local device.
 */
/*! @{ */
#define DLNA_E_NOTIFY_UNACCEPTED      -303
/*! @} */

/** @name DLNA_E_INVALID_ARGUMENT [-501]
 *  {\tt DLNA_E_INVALID_ARGUMENT} signifies that one or more of the parameters
 *  passed to a function is invalid.  Refer to the individual function
 *  descriptions for the acceptable ranges for parameters.
 */
/*! @{ */
#define DLNA_E_INVALID_ARGUMENT       -501
/*! @} */

/** @name DLNA_E_FILE_NOT_FOUND [-502]
 *  {\tt DLNA_E_FILE_NOT_FOUND} signifies that the filename passed
 *  to one of the device registration functions was not found or was not
 *  accessible.
 */
/*! @{ */
#define DLNA_E_FILE_NOT_FOUND         -502
/*! @} */

/** @name DLNA_E_FILE_READ_ERROR [-503]
 *  {\tt DLNA_E_FILE_READ_ERROR} signifies an error when reading a file.
 */
/*! @{ */
#define DLNA_E_FILE_READ_ERROR        -503
/*! @} */

/** @name DLNA_E_EXT_NOT_XML [-504]
 *  {\tt DLNA_E_EXT_NOT_XML} signifies that the file name of the description
 *  document passed to {\bf dlnaRegisterRootDevice2} does not end in ".xml".
 */
/*! @{ */
#define DLNA_E_EXT_NOT_XML            -504
/*! @} */

#define DLNA_E_NO_WEB_SERVER          -505
#define DLNA_E_OUTOF_BOUNDS	      -506

/** @name DLNA_E_NOT_FOUND [-507]
 *  {\tt DLNA_E_NOT_FOUND} signifies that the response to a SOAP request
 *  did not contain the required XML constructs.  
 */
/*! @{ */
#define DLNA_E_NOT_FOUND	      -507
/*! @} */

/** @name DLNA_E_INTERNAL_ERROR [-911]
 *  {\tt DLNA_E_INTERNAL_ERROR} is the generic error code for internal
 *  conditions not covered by other error codes.
 */
/*! @{ */
#define DLNA_E_INTERNAL_ERROR         -911
/*! @} */

/* SOAP-related error codes */
#define DLNA_SOAP_E_INVALID_ACTION    401
#define DLNA_SOAP_E_INVALID_ARGS      402
#define DLNA_SOAP_E_OUT_OF_SYNC       403
#define DLNA_SOAP_E_INVALID_VAR       404
#define DLNA_SOAP_E_ACTION_FAILED     501

/*! @} */

#ifndef OUT
#define OUT
#endif

#ifndef IN
#define IN
#endif

#ifndef INOUT
#define INOUT
#endif

#include "upnpdebug.h"

enum dlnaOpenFileMode{DLNA_READ, DLNA_WRITE};

/*! @name Constants, Structures, and Types */
/*! @{ */

/** Returned when a control point application registers with {\bf
 *  dlnaRegisterClient}.  Client handles can only be used with 
 *  functions that operate with a client handle.  */

typedef int  dlnaClient_Handle;

/** Returned when a device application registers with {\bf
 *  dlnaRegisterRootDevice} or {\bf dlnaRegisterRootDevice2}.  Device handles 
 *  can only be used with functions that operate with a device handle.  */

typedef int  dlnaDevice_Handle;

/** @name UPnP_EventType
    @memo The reason code for an event callback.
    @doc The {\bf Event} parameter will be different depending on the
         reason for the callback.  The descriptions for each event
	 type describe the contents of the {\bf Event} parameter.
  */

enum dlna_EventType_e {

  /*
   * Control callbacks
   */

  /** Received by a device when a control point issues a control
   *  request.  The {\bf Event} parameter contains a pointer to a {\bf
   *  dlna_Action_Request} structure containing the action.  The application
   *  stores the results of the action in this structure. */

  DLNA_CONTROL_ACTION_REQUEST,

  /** A {\bf dlnaSendActionAsync} call completed. The {\bf Event}
   *  parameter contains a pointer to a {\bf dlna_Action_Complete} structure
   *  with the results of the action.  */

  DLNA_CONTROL_ACTION_COMPLETE,

  /** Received by a device when a query for a single service variable
   *  arrives.  The {\bf Event} parameter contains a pointer to a {\bf
   *  dlna_State_Var_Request} structure containing the name of the variable
   *  and value.  */

  DLNA_CONTROL_GET_VAR_REQUEST,

  /** A {\bf dlnaGetServiceVarStatus} call completed. The {\bf Event}
   *  parameter contains a pointer to a {\bf dlna_State_Var_Complete} structure
   *  containing the value for the variable.  */

  DLNA_CONTROL_GET_VAR_COMPLETE,

  /*
   * Discovery callbacks
   */

  /** Received by a control point when a new device or service is available.  
   *  The {\bf Event} parameter contains a pointer to a {\bf
   *  dlna_Discovery} structure with the information about the device
   *  or service.  */

  DLNA_DISCOVERY_ADVERTISEMENT_ALIVE,

  /** Received by a control point when a device or service shuts down. The {\bf
   *  Event} parameter contains a pointer to a {\bf dlna_Discovery}
   *  structure containing the information about the device or
   *  service.  */

  DLNA_DISCOVERY_ADVERTISEMENT_BYEBYE,

  /** Received by a control point when a matching device or service responds.
   *  The {\bf Event} parameter contains a pointer to a {\bf
   *  dlna_Discovery} structure containing the information about
   *  the reply to the search request.  */

  DLNA_DISCOVERY_SEARCH_RESULT,

  /** Received by a control point when the search timeout expires.  The
   *  SDK generates no more callbacks for this search after this 
   *  event.  The {\bf Event} parameter is {\tt NULL}.  */

  DLNA_DISCOVERY_SEARCH_TIMEOUT,

  /*
   * Eventing callbacks
   */

  /** Received by a device when a subscription arrives.
   *  The {\bf Event} parameter contains a pointer to a {\bf
   *  dlna_Subscription_Request} structure.  At this point, the
   *  subscription has already been accepted.  {\bf dlnaAcceptSubscription}
   *  needs to be called to confirm the subscription and transmit the
   *  initial state table.  This can be done during this callback.  The SDK
   *  generates no events for a subscription unless the device 
   *  application calls {\bf dlnaAcceptSubscription}.
   */

  DLNA_EVENT_SUBSCRIPTION_REQUEST,

  /** Received by a control point when an event arrives.  The {\bf
   *  Event} parameter contains a {\bf dlna_Event} structure
   *  with the information about the event.  */

  DLNA_EVENT_RECEIVED,

  /** A {\bf dlnaRenewSubscriptionAsync} call completed. The status of
   *  the renewal is in the {\bf Event} parameter as a {\bf
   *  dlna_Event_Subscription} structure.  */

  DLNA_EVENT_RENEWAL_COMPLETE,

  /** A {\bf dlnaSubscribeAsync} call completed. The status of the
   * subscription is in the {\bf Event} parameter as a {\bf
   * dlna_Event_Subscription} structure.  */

  DLNA_EVENT_SUBSCRIBE_COMPLETE,

  /** A {\bf dlnaUnSubscribeAsync} call completed. The status of the
   *  subscription is in the {\bf Event} parameter as a {\bf
   *  dlna_Event_Subscribe} structure.  */

  DLNA_EVENT_UNSUBSCRIBE_COMPLETE,

  /** The auto-renewal of a client subscription failed.   
   *  The {\bf Event} parameter is a {\bf dlna_Event_Subscribe} structure 
   *  with the error code set appropriately. The subscription is no longer 
   *  valid. */

  DLNA_EVENT_AUTORENEWAL_FAILED,

  /** A client subscription has expired. This will only occur 
   *  if auto-renewal of subscriptions is disabled.
   *  The {\bf Event} parameter is a {\bf dlna_Event_Subscribe}
   *  structure. The subscription is no longer valid. */
  
  DLNA_EVENT_SUBSCRIPTION_EXPIRED

};

typedef enum dlna_EventType_e dlna_EventType;

/** The {\bf dlna_SID} holds the subscription identifier for a subscription
    between a client and a device.  The SID is a string representation of
    a globally unique id (GUID) and should not be modified.
  */
    
typedef char dlna_SID[44];

/** @name dlna_SType
    @memo Represents the different types of searches that
          can be performed using the SDK for UPnP Devices API.
    @doc  By specifying these different values to 
          {\bf dlnaSearchAsync}, the control point application
	  can control the scope of the search from all devices
	  to specific devices or services.
  */

enum dlna_SType_e {

  /** Search for all devices and services on the network. */
  DLNA_S_ALL,    

  /** Search for all root devices on the network. */
  DLNA_S_ROOT,   

  /** Search for a particular device type or a particular device
      instance. */
  DLNA_S_DEVICE, 
                       
  /** Search for a particular service type, possibly on a particular
   *  device type or device instance.  */
  DLNA_S_SERVICE 
                       
};

typedef enum dlna_SType_e dlna_SType;

/** @name dlna_DescType
    @memo Specifies the type of description in 
          {\bf dlnaRegisterRootDevice2}.
    @doc  These values control how {\bf dlnaRegisterRootDevice2}
          interprets the {\bf description} parameter.
   */
enum dlna_DescType_e { 

	/** The description is the URL to the description document. */
	DLNAREG_URL_DESC, 
	
	/** The description is a file name on the local file system 
	    containing the description of the device. */
	DLNAREG_FILENAME_DESC,
    
	/** The description is a pointer to a character array containing 
	    the XML description document. */
	DLNAREG_BUF_DESC 

};

typedef enum dlna_DescType_e dlna_DescType;

/** Returned as part of a {\bf DLNA_CONTROL_ACTION_COMPLETE} callback.  */

struct dlna_Action_Request
{
  /** The result of the operation. */
  int ErrCode;

  /** The socket number of the connection to the requestor. */
  int Socket;

  /** The error string in case of error. */
  char ErrStr[LINE_SIZE];

 /** The Action Name. */
  char ActionName[NAME_SIZE];

  /** The unique device ID. */
  char DevUDN[NAME_SIZE];

  /** The service ID. */
  char ServiceID[NAME_SIZE];

  /** The DOM document describing the action. */
  IXML_Document *ActionRequest;

  /** The DOM document describing the result of the action. */
  IXML_Document *ActionResult;

  /** IP address of the control point requesting this action. */
  struct in_addr CtrlPtIPAddr;

  /** The DOM document containing the information from the
      the SOAP header. */
  IXML_Document *SoapHeader;
};

struct dlna_Action_Complete
{
  /** The result of the operation. */
  int ErrCode;

  /** The control URL for service. */
  char CtrlUrl[NAME_SIZE];

  /** The DOM document describing the action. */
  IXML_Document *ActionRequest;

  /** The DOM document describing the result of the action. */
  IXML_Document *ActionResult;

};

/** Represents the request for current value of a state variable in a service
 *  state table.  */

struct dlna_State_Var_Request
{
  /** The result of the operation. */
  int ErrCode;

  /** The socket number of the connection to the requestor. */
  int Socket;

  /** The error string in case of error. */
  char ErrStr[LINE_SIZE];

  /** The unique device ID. */
  char DevUDN[NAME_SIZE];

  /** The  service ID. */
  char ServiceID[NAME_SIZE];

  /** The name of the variable. */
  char StateVarName[NAME_SIZE];

  /** IP address of sender requesting the state variable. */
  struct in_addr CtrlPtIPAddr;

  /** The current value of the variable. This needs to be allocated by 
   *  the caller.  When finished with it, the SDK frees this {\bf DOMString}. */
  DOMString CurrentVal;
};

/** Represents the reply for the current value of a state variable in an
    asynchronous call. */

struct dlna_State_Var_Complete
{
  /** The result of the operation. */
  int ErrCode;

  /** The control URL for the service. */
  char CtrlUrl[NAME_SIZE];

  /** The name of the variable. */
  char StateVarName[NAME_SIZE];

  /** The current value of the variable or error string in case of error. */
  DOMString CurrentVal;
};

/** Returned along with a {\bf DLNA_EVENT_RECEIVED} callback.  */

struct dlna_Event
{
  /** The subscription ID for this subscription. */
  dlna_SID Sid;

  /** The event sequence number. */
  int EventKey;

  /** The DOM tree representing the changes generating the event. */
  IXML_Document *ChangedVariables;

};

/*
 * This typedef is required by Doc++ to parse the last entry of the 
 * dlna_Discovery structure correctly.
 */


/** Returned in a {\bf DLNA_DISCOVERY_RESULT} callback. */
struct dlna_Discovery
{
	/** The result code of the {\bf dlnaSearchAsync} call. */
	int  ErrCode;                  
				     
	/** The expiration time of the advertisement. */
	int  Expires;                  
				     
	/** The unique device identifier. */
	char DeviceId[LINE_SIZE];      

	/** The device type. */
	char DeviceType[LINE_SIZE];    

	/** The service type. */
	char ServiceType[LINE_SIZE];

	/** The service version. */
	char ServiceVer[LINE_SIZE];    

	/** The URL to the UPnP description document for the device. */
	char Location[LINE_SIZE];      

	/** The operating system the device is running. */
	char Os[LINE_SIZE];            
				     
	/** Date when the response was generated. */
	char Date[LINE_SIZE];            
				     
	/** Confirmation that the MAN header was understood by the device. */
	char Ext[LINE_SIZE];           
				     
	/** The host address of the device responding to the search. */
	struct sockaddr_in DestAddr; 
};

/** Returned along with a {\bf DLNA_EVENT_SUBSCRIBE_COMPLETE} or {\bf
 * DLNA_EVENT_UNSUBSCRIBE_COMPLETE} callback.  */

struct dlna_Event_Subscribe {

  /** The SID for this subscription.  For subscriptions, this only
   *  contains a valid SID if the {\bf dlna_EventSubscribe.result} field
   *  contains a {\tt DLNA_E_SUCCESS} result code.  For unsubscriptions,
   *  this contains the SID from which the subscription is being
   *  unsubscribed.  */

  dlna_SID Sid;            

  /** The result of the operation. */
  int ErrCode;              

  /** The event URL being subscribed to or removed from. */
  char PublisherUrl[NAME_SIZE]; 

  /** The actual subscription time (for subscriptions only). */
  int TimeOut;              
                              
};
  
/** Returned along with a {\bf DLNA_EVENT_SUBSCRIPTION_REQUEST}
 *  callback.  */

struct dlna_Subscription_Request
{
  /** The identifier for the service being subscribed to. */
  char *ServiceId; 

  /** Universal device name. */
  char *UDN;       

  /** The assigned subscription ID for this subscription. */
  dlna_SID Sid;

};


struct File_Info
{
  /** The length of the file. A length less than 0 indicates the size 
   *  is unknown, and data will be sent until 0 bytes are returned from
   *  a read call. */
  off_t file_length;

  /** The time at which the contents of the file was modified;
   *  The time system is always local (not GMT). */
  time_t last_modified;

  /** If the file is a directory, {\bf is_directory} contains
   * a non-zero value. For a regular file, it should be 0. */
  int is_directory;

  /** If the file or directory is readable, this contains 
   * a non-zero value. If unreadable, it should be set to 0. */
  int is_readable;

  /** The content type of the file. This string needs to be allocated 
   *  by the caller using {\bf ixmlCloneDOMString}.  When finished 
   *  with it, the SDK frees the {\bf DOMString}. */
   
  DOMString content_type;

};

/* The type of handle returned by the web server for open requests. */

typedef void *dlnaWebFileHandle;

/** The {\bf dlnaVirtualDirCallbacks} structure contains the pointers to
 *  file-related callback functions a device application can register to
 *  virtualize URLs.  
 */
struct dlnaVirtualDirCallbacks
{
  void *cookie;
  
  /** Called by the web server to query information on a file.  The callback
   *  should return 0 on success or -1 on an error. */
  int (*get_info) (
    IN void *cookie,
    IN  const char *filename,     /** The name of the file to query. */
    OUT struct File_Info *info    /** Pointer to a structure to store the 
                                      information on the file. */
    );
                                  
  /** Called by the web server to open a file.  The callback should return
   *  a valid handle if the file can be opened.  Otherwise, it should return
   *  {\tt NULL} to signify an error. */
  dlnaWebFileHandle (*open)(
    IN void *cookie,
    IN const char *filename,       /** The name of the file to open. */ 
    IN enum dlnaOpenFileMode Mode  /** The mode in which to open the file. 
                                       Valid values are {\tt DLNA_READ} or 
                                       {\tt DLNA_WRITE}. */
    );

  /** Called by the web server to perform a sequential read from an open
   *  file.  The callback should copy {\bf buflen} bytes from the file into
   *  the buffer.
   *  @return [int] An integer representing one of the following:
   *    \begin{itemize}
   *      \item {\tt 0}:  The file contains no more data (EOF).
   *      \item {\tt >0}: A successful read of the number of bytes in the 
   *                      return code.
   *      \item {\tt <0}: An error occurred reading the file.
   *    \end{itemzie}
   */
   int (*read) (
     IN void *cookie,
     IN dlnaWebFileHandle fileHnd,  /** The handle of the file to read. */
     OUT char *buf,                 /** The buffer in which to place the 
				        data. */
     IN size_t buflen               /** The size of the buffer (i.e. the 
                                        number of bytes to read). */
     );

  /** Called by the web server to perform a sequential write to an open
   *  file.  The callback should write {\bf buflen} bytes into the file from
   *  the buffer.  It should return the actual number of bytes written, 
   *  which might be less than {\bf buflen} in the case of a write error.
   */
   int (*write) (
     IN void *cookie,
     IN dlnaWebFileHandle fileHnd, /** The handle of the file to write. */
     IN char *buf,                 /** The buffer with the bytes to write. */
     IN size_t buflen              /** The number of bytes to write. */
     );

  /** Called by the web server to move the file pointer, or offset, into
   *  an open file.  The {\bf origin} parameter determines where to start
   *  moving the file pointer.  A value of {\tt SEEK_CUR} moves the
   *  file pointer relative to where it is.  The {\bf offset} parameter can
   *  be either positive (move forward) or negative (move backward).  
   *  {\tt SEEK_END} moves relative to the end of the file.  A positive 
   *  {\bf offset} extends the file.  A negative {\bf offset} moves backward 
   *  in the file.  Finally, {\tt SEEK_SET} moves to an absolute position in 
   *  the file. In this case, {\bf offset} must be positive.  The callback 
   *  should return 0 on a successful seek or a non-zero value on an error.
   */
   int (*seek) (
     IN void *cookie,
     IN dlnaWebFileHandle fileHnd,  /** The handle of the file to move the 
                                        file pointer. */
     IN off_t offset,                /** The number of bytes to move in the 
                                        file.  Positive values move foward and 
                                        negative values move backward.  Note 
                                        that this must be positive if the 
                                        {\bf origin} is {\tt SEEK_SET}. */
     IN int origin                  /** The position to move relative to.  It 
                                        can be {\tt SEEK_CUR} to move relative 
                                        to the current position, 
					{\tt SEEK_END} to move relative to 
					the end of the file, or {\tt 
					SEEK_SET} to specify an absolute 
					offset. */
     );

   /** Called by the web server to close a file opened via the {\bf open}
    *  callback.  It should return 0 on success, or a non-zero value on an 
    *  error.
    */
   int (*close) (
     IN void *cookie,
     IN dlnaWebFileHandle fileHnd   /** The handle of the file to close. */
     );

};

typedef struct virtual_Dir_List
{
    struct virtual_Dir_List *next;
    char dirName[NAME_SIZE];
} virtualDirList;

/** All callback functions share the same prototype, documented below.
 *  Note that any memory passed to the callback function
 *  is valid only during the callback and should be copied if it
 *  needs to persist.  This callback function needs to be thread
 *  safe.  The context of the callback is always on a valid thread 
 *  context and standard synchronization methods can be used.  Note, 
 *  however, because of this the callback cannot call SDK functions
 *  unless explicitly noted.
 *
 *  \begin{verbatim}
      int CallbackFxn( dlna_EventType EventType, void* Event, void* Cookie );
    \end{verbatim} 
 *
 *  where {\bf EventType} is the event that triggered the callback, 
 *  {\bf Event} is a structure that denotes event-specific information for that
 *  event, and {\bf Cookie} is the user data passed when the callback was
 *  registered.
 *
 *  See {\bf dlna_EventType} for more information on the callback values and
 *  the associated {\bf Event} parameter.  
 *
 *  The return value of the callback is currently ignored.  It may be used
 *  in the future to communicate results back to the SDK.
 */

typedef int  (*dlna_FunPtr) (
    IN dlna_EventType EventType, 
    IN void *Event, 
    IN void *Cookie
    );

/*! @} */ /* Constants, Structures, and Types */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*! @name Initialization and Registration */
/*! @{ */
/** Initializes the Linux SDK for UPnP Devices. This function must be called
 *  before any other API function can be called.  It should be called
 *  only once.  Subsequent calls to this API return a {\tt DLNA_E_INIT}
 *  error code.
 *
 *  Optionally, the application can specify a host IP address (in the
 *  case of a multi-homed configuration) and a port number to use for
 *  all UPnP operations.  Since a port number can be used only by one
 *  process, multiple processes using the SDK must specify
 *  different port numbers.
 *
 *  If unspecified, the SDK will use the first adapter's IP address 
 *  and an arbitrary port.
 *
 *  This call is synchronous.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist 
 *              to initialize the SDK.
 *      \item {\tt DLNA_E_INIT}: The SDK is already initialized. 
 *      \item {\tt DLNA_E_INIT_FAILED}: The SDK initialization 
 *              failed for an unknown reason.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_LISTEN}: An error occurred listening to a socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error ocurred creating a socket.
 *      \item {\tt DLNA_E_INTERNAL_ERROR}: An internal error ocurred.
 *    \end{itemize} */

EXPORT_SPEC int dlnaInit(
    IN const char *HostIP,      /** The host IP address to use, in 
                                    string format, for example "192.168.0.1", 
                                    or {\tt NULL} to use the first adapter's 
                                    IP address. */
    IN unsigned short DestPort  /** The destination port number to use.  0 
                                    will pick an arbitrary free port. */
    );

/** Terminates the Linux SDK for UPnP Devices. This function must be the last 
 *  API function called. It should be called only once. Subsequent calls to 
 *  this API return a {\tt DLNA_E_FINISH} error code.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_FINISH}: The SDK is already terminated or 
 *                                 it is not initialized. 
 *    \end{itemize} */

EXPORT_SPEC int dlnaFinish();

/** If '0' is used as the port number in {\bf dlnaInit}, then this
 *  function can be used to retrieve the actual port allocated to
 *  the SDK. If {\bf dlnaInit} has not succeeded then 0 is 
 *  returned.
 *
 *  @return [unsigned short] The port on which an internal server is 
 *                           listening for UPnP related requests. 
 */
EXPORT_SPEC unsigned short dlnaGetServerPort(void);

/** If {\tt NULL} is used as the IP address in {\bf dlnaInit}, then this
 *  function can be used to retrieve the actual interface address
 *  on which device is running. If {\bf dlnaInit} has not succeeded 
 *  then {\tt NULL} is returned.
 *
 *  @return [char*] The IP address on which an internal server is listening 
 *                  for UPnP related requests. 
 */
EXPORT_SPEC char * dlnaGetServerIpAddress(void);

/** {\bf dlnaRegisterClient} registers a control point application with the
 *  SDK.  A control point application cannot make any other API calls
 *  until it registers using this function.
 *
 *  {\bf dlnaRegisterClient} is a synchronous call and generates no callbacks.
 *  Callbacks can occur as soon as this function returns.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_FINISH}: The SDK is already terminated or 
 *                                 is not initialized. 
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Callback} or {\bf Hnd} 
 *              is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              register this control point.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaRegisterClient(
    IN dlna_FunPtr Callback,   /** Pointer to a function for receiving 
                                   asynchronous events. */
    IN const void *Cookie,     /** Pointer to user data returned with the 
                                   callback function when invoked. */
    OUT dlnaClient_Handle *Hnd /** Pointer to a variable to store the 
                                   new control point handle. */
    );  

/** {\bf dlnaRegisterRootDevice} registers a device application with
 *  the SDK.  A device application cannot make any other API
 *  calls until it registers using this function.  Device applications
 *  can also register as control points (see {\bf dlnaRegisterClient}
 *  to get a control point handle to perform control point
 *  functionality).
 *
 *  {\bf dlnaRegisterRootDevice} is synchronous and does not generate
 *  any callbacks.  Callbacks can occur as soon as this function returns.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_FINISH}: The SDK is already terminated or 
 *                                 is not initialized. 
 *      \item {\tt DLNA_E_INVALID_DESC}: The description document was not 
 *              a valid device description.
 *      \item {\tt DLNA_E_INVALID_URL}: The URL for the description document 
 *              is not valid.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Callback} or {\bf Hnd} 
 *              is not a valid pointer or {\bf DescURL} is {\tt NULL}.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting the 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: There are insufficient resources to 
 *              register this root device.
 *    \end{itemize} */

EXPORT_SPEC int dlnaRegisterRootDevice(
    IN const char *DescUrl,    /** Pointer to a string containing the 
                                   description URL for this root device 
                                   instance. */
    IN dlna_FunPtr Callback,   /** Pointer to the callback function for 
                                   receiving asynchronous events. */
    IN const void *Cookie,     /** Pointer to user data returned with the 
                                   callback function when invoked. */
    OUT dlnaDevice_Handle *Hnd /** Pointer to a variable to store the 
                                   new device handle. */
    );

/** {\bf dlnaRegisterRootDevice2} is similar to {\bf dlnaRegisterRootDevice},
 *  except that it also allows the description document to be specified as a 
 *  file or a memory buffer. The description can also be configured to have the
 *  correct IP and port address.
 *
 *  NOTE: For the configuration to be functional, the internal web server
 *  MUST be present. In addition, the web server MUST be activated
 *  (using {\bf dlnaSetWebServerRootDir}) before calling this function.
 *  The only condition where the web server can be absent is if the 
 *  description document is specified as a URL and no configuration is 
 *  required (i.e. {\tt config_baseURL = 0}.)
 *
 *  {\bf dlnaRegisterRootDevice2} is synchronous and does not generate
 *  any callbacks.  Callbacks can occur as soon as this function returns.
 *
 *  Examples of using different types of description documents:
 *  \begin{verbatim}
    1) Description specified as a URL:
          descriptionType == DLNAREG_URL_DESC
          description is the URL
          bufferLen = 0 (ignored)
    2) Description specified as a file:
          descriptionType == DLNAREG_FILENAME_DESC
          description is a filename
          bufferLen = 0 (ignored)
    3) Description specified as a memory buffer:
          descriptionType == DLNAREG_BUF_DESC
          description is pointer to a memory buffer
          bufferLen == length of memory buffer
    \end{verbatim}
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_FINISH}: The SDK is already terminated or 
 *                                 is not initialized.
 *      \item {\tt DLNA_E_INVALID_DESC}: The description document is not 
 *              a valid device description.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Callback} or {\bf Hnd} 
 *              is not a valid pointer or {\bf DescURL} is {\tt NULL}.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting the 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: There are insufficient resources to 
 *              register this root device.
 *      \item {\tt DLNA_E_URL_TOO_BIG}: Length of the URL is bigger than the 
 *              internal buffer.
 *      \item {\tt DLNA_E_FILE_NOT_FOUND}: The description file could not 
 *              be found.
 *      \item {\tt DLNA_E_FILE_READ_ERROR}: An error occurred reading the 
 *              description file.
 *      \item {\tt DLNA_E_INVALID_URL}: The URL to the description document 
 *              is invalid.
 *      \item {\tt DLNA_E_EXT_NOT_XML}: The URL to the description document 
 *              or file should have a {\tt .xml} extension.
 *      \item {\tt DLNA_E_NO_WEB_SERVER}: The internal web server has been 
 *              compiled out; the SDK cannot configure itself from the 
 *              description document.
 *    \end{itemize} */
 
EXPORT_SPEC int dlnaRegisterRootDevice2(
    IN dlna_DescType descriptionType,/** The type of the description 
                                         document. */
    IN const char* description,      /** Treated as a URL, file name or 
                                         memory buffer depending on 
                                         description type. */
    IN size_t bufferLen,             /** The length of memory buffer if 
                                         passing a description in a buffer, 
                                         otherwise it is ignored. */
    IN int config_baseURL,           /** If nonzero, {\tt URLBase} of 
                                         description document is 
                                         configured and the description 
                                         is served using the internal 
                                         web server. */
    IN dlna_FunPtr Fun,              /** Pointer to the callback function 
                                         for receiving asynchronous 
                                         events. */
    IN const void* Cookie,           /** Pointer to user data returned 
                                         with the callback function when 
                                         invoked. */
    OUT dlnaDevice_Handle* Hnd       /** Pointer to a variable to store 
                                         the new device handle. */
    );

/** {\bf dlnaUnRegisterClient} unregisters a control point application, 
 *  unsubscribing all active subscriptions. After this call, the 
 *  {\bf dlnaClient_Handle} is no longer valid.
 *
 *  {\bf dlnaUnRegisterClient} is a synchronous call and generates no
 *  callbacks.  The SDK generates no more callbacks after this 
 *  function returns.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *                   point handle.
 *    \end{itemize} */

EXPORT_SPEC int dlnaUnRegisterClient(
    IN dlnaClient_Handle Hnd  /** The handle of the control point instance 
                                  to unregister. */
    );

/** Unregisters a root device registered with {\bf dlnaRegisterRootDevice} or
 *  {\bf dlnaRegisterRootDevice2}. After this call, the 
 *  {\bf dlnaDevice_Handle} is no longer valid. For all advertisements that 
 *  have not yet expired, the SDK sends a device unavailable message 
 *  automatically.
 *
 *  {\bf dlnaUnRegisterRootDevice} is a synchronous call and generates no
 *  callbacks.  Once this call returns, the SDK will no longer 
 *  generate callbacks to the application.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid  
 *              device handle.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaUnRegisterRootDevice(
   IN dlnaDevice_Handle /** The handle of the root device instance to 
                            unregister. */
   );


/** OBSOLETE METHOD : use {\bf dlnaSetMaxContentLength} instead.
 * Warning: the Handle argument provided here is not used, so the effect
 * of this function is global to the SDK (= same as 
 * {\bf dlnaSetMaxContentLength} ).
 */
EXPORT_SPEC int dlnaSetContentLength(
    IN dlnaClient_Handle Hnd,  
    IN int contentLength       
    );


/** Sets the maximum content-length that the SDK will process on an incoming 
 *  SOAP requests or responses. This API allows devices that have memory 
 *  constraints to exhibit consistent behaviour if the size of the 
 *  incoming SOAP message exceeds the memory that device can allocate. 
 *  The default maximum content-length is {\tt DEFAULT_SOAP_CONTENT_LENGTH} 
 *  = 16K bytes.
 *   
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *    \end{itemize}
 */
EXPORT_SPEC int dlnaSetMaxContentLength(
    IN size_t contentLength    /** The maximum permissible content length 
			           for incoming SOAP actions, in bytes. */
    );

/*! @} */ /* Initialization and Registration */

/******************************************************************************
 ******************************************************************************
 *                                                                            *
 *                        D I S C O V E R Y                                   *
 *                                                                            *
 ******************************************************************************
 ******************************************************************************/

/*! @name Discovery */
/*! @{ */

/** {\bf dlnaSearchAsync} searches for devices matching the given
 *  search target.  The function returns immediately and the SDK 
 *  calls the default callback function, registered during the 
 *  {\bf dlnaRegisterClient} call, for each matching root device,
 *  device, or service.  The application specifies the search type by the 
 *  {\bf Target} parameter.  
 *
 *  Note that there is no way for the SDK to distinguish which client
 *  instance issued a particular search.  Therefore, the client can get
 *  search callbacks that do not match the original criteria of the search.
 *  Also, the application will receive multiple callbacks for each search.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf Target} is {\tt NULL}.
 *    \end{itemize} */

EXPORT_SPEC int dlnaSearchAsync(
    IN dlnaClient_Handle Hnd, /** The handle of the client performing 
                                  the search. */
    IN int Mx,                /** The time, in seconds, to wait for 
                                  responses. If the time is greater 
                                  than {\tt MAX_SEARCH_TIME} then the time is 
                                  set to {\tt MAX_SEARCH_TIME}. If the time is 
                                  less than {\tt MIN_SEARCH_TIME} then the 
                                  time is set to {\tt MIN_SEARCH_TIME}. */ 
    IN const char *Target,    /** The search target as defined in the UPnP 
                                  Device Architecture v1.0 specification. */
    IN const void *Cookie     /** The user data to pass when the callback 
                                  function is invoked. */
    ); 

/** {\bf dlnaSendAdvertisement} sends out the discovery announcements for
 *  all devices and services for a device.  Each announcement is made with
 *  the same expiration time.
 *
 *  {\bf dlnaSendAdvertisement} is a synchronous call.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid 
 *              device handle.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: There are insufficient resources to 
 *              send future advertisements.
 *    \end{itemize}
 */
EXPORT_SPEC int dlnaSendAdvertisement(
    IN dlnaDevice_Handle Hnd, /** The device handle for which to send out the 
                                  announcements. */
    IN int Exp                /** The expiration age, in seconds, of 
                                  the announcements. */
    );

/*! @} */ /* Discovery */

/******************************************************************************
 ******************************************************************************
 *                                                                            *
 *                            C O N T R O L                                   *
 *                                                                            *
 ******************************************************************************
 ******************************************************************************/

/*! @name Control */
/*! @{ */

/** {\bf dlnaGetServiceVarStatus} queries the state of a state 
 *  variable of a service on another device.  This is a synchronous call.
 *  A positive return value indicates a SOAP error code, whereas a negative
 *  return code indicates an SDK error code. {\bf Note that the use of this 
 *  function is deprecated by the UPnP Forum}.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf ActionUrl} is not a valid URL.
 *      \item {\tt DLNA_E_INVALID_DESC}: The XML document was not 
 *              found or it does not contain a valid XML description.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf StVarVal} is not a valid 
 *              pointer or {\bf VarName} or {\bf ActionUrl} is {\tt NULL}. 
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *      \item {\tt DLNA_SOAP_E_INVALID_VAR}: The given variable is invalid 
 *              according to the device.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaGetServiceVarStatus(
    IN dlnaClient_Handle Hnd,     /** The handle of the control point. */
    IN const char *ActionURL,     /** The URL of the service. */
    IN const char *VarName,       /** The name of the variable to query. */
    OUT DOMString *StVarVal       /** The pointer to store the value 
                                      for {\bf VarName}. The SDK 
                                      allocates this string and the caller 
                                      needs to free it using 
				      {\bf ixmlFreeDOMString}. */
    );

/** {\bf dlnaGetServiceVarStatusAsync} queries the state of a variable of a 
 *  service, generating a callback when the operation is complete. {\bf Note 
 *  that the use of this function is deprecated by the UPnP Forum}.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf ActionUrl} is not a valid URL.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf VarName}, {\bf Fun} or 
 *              {\bf ActionUrl} is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaGetServiceVarStatusAsync(
    IN dlnaClient_Handle Hnd, /** The handle of the control point. */
    IN const char *ActionURL, /** The URL of the service. */
    IN const char *VarName,   /** The name of the variable to query. */
    IN dlna_FunPtr Fun,       /** Pointer to a callback function to 
                                  be invoked when the operation is complete. */
    IN const void *Cookie     /** Pointer to user data to pass to the 
                                  callback function when invoked. */
    );

/** {\bf dlnaSendAction} sends a message to change a state variable
 *  in a service.  This is a synchronous call that does not return until the 
 *  action is complete.
 * 
 *  Note that a positive return value indicates a SOAP-protocol error code.
 *  In this case,  the error description can be retrieved from {\bf RespNode}.
 *  A negative return value indicates an SDK error.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf ActionUrl} is not a valid URL.
 *      \item {\tt DLNA_E_INVALID_ACTION}: This action is not valid.
 *      \item {\tt DLNA_E_INVALID_DEVICE}: {\bf DevUDN} is not a 
 *              valid device.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf ServiceType}, {\bf Action}, 
 *              {\bf ActionUrl}, or 
 *              {\bf RespNode} is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSendAction(
    IN dlnaClient_Handle Hnd,     /** The handle of the control point 
                                      sending the action. */
    IN const char *ActionURL,     /** The action URL of the service. */
    IN const char *ServiceType,   /** The type of the service. */
    IN const char *DevUDN,        /** This parameter is ignored and must be
				      {\tt NULL}. */
    IN IXML_Document *Action,     /** The DOM document for the action. */
    OUT IXML_Document **RespNode  /** The DOM document for the response 
                                    to the action.  The SDK allocates 
                                    this document and the caller needs to free 
                                    it.  */
   );

/** {\bf dlnaSendActionEx} sends a message to change a state variable
 *  in a service.  This is a synchronous call that does not return until the 
 *  action is complete.
 *
 *  Note that a positive return value indicates a SOAP-protocol error code.
 *  In this case,  the error description can be retrieved from {\bf RespNode}.
 *  A negative return value indicates an SDK error.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf ActionUrl} is not a valid URL.
 *      \item {\tt DLNA_E_INVALID_ACTION}: This action is not valid.
 *      \item {\tt DLNA_E_INVALID_DEVICE}: {\bf DevUDN} is not a 
 *              valid device.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf ServiceType}, {\bf Action}, 
 *              {\bf ActionUrl}, or 
 *              {\bf RespNode} is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSendActionEx(
    IN dlnaClient_Handle Hnd,    /** The handle of the control point 
                                     sending the action. */
    IN const char *ActionURL,    /** The action URL of the service. */
    IN const char *ServiceType,  /** The type of the service. */
    IN const char *DevUDN,       /** This parameter is ignored and must be
				     {\tt NULL}. */
    IN IXML_Document *Header,    /** The DOM document for the SOAP header. 
                                     This may be {\tt NULL} if the header is 
				     not required. */
    IN IXML_Document *Action,    /** The DOM document for the action. */
    OUT IXML_Document **RespNode /** The DOM document for the response 
                                     to the action.  The SDK allocates 
                                     this document and the caller needs to free 
                                     it.  */
   );

/** {\bf dlnaSendActionAsync} sends a message to change a state variable
 *  in a service, generating a callback when the operation is complete.
 *  See {\bf dlnaSendAction} for comments on positive return values. These 
 *  positive return values are sent in the event struct associated with the
 *  {\tt DLNA_CONTROL_ACTION_COMPLETE} event.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf ActionUrl} is an invalid URL.
 *      \item {\tt DLNA_E_INVALID_DEVICE}: {\bf DevUDN} is an invalid device.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Fun} is not a valid 
 *              callback function or {\bf ServiceType}, {\bf Act}, or 
 *              {\bf ActionUrl} is {\tt NULL}.
 *      \item {\tt DLNA_E_INVALID_ACTION}: This action is not valid.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSendActionAsync(
    IN dlnaClient_Handle Hnd,   /** The handle of the control point 
                                    sending the action. */
    IN const char *ActionURL,   /** The action URL of the service. */
    IN const char *ServiceType, /** The type of the service. */
    IN const char *DevUDN,      /** This parameter is ignored and must be
				    {\tt NULL}. */
    IN IXML_Document *Action,   /** The DOM document for the action to 
                                    perform on this device. */
    IN dlna_FunPtr Fun,         /** Pointer to a callback function to 
                                    be invoked when the operation 
		                    completes. */
    IN const void *Cookie       /** Pointer to user data that to be 
                                    passed to the callback when invoked. */
    );

/** {\bf dlnaSendActionExAsync} sends a message to change a state variable
 *  in a service, generating a callback when the operation is complete.
 *  See {\bf dlnaSendAction} for comments on positive return values. These 
 *  positive return values are sent in the event struct associated with the
 *  {\tt DLNA_CONTROL_ACTION_COMPLETE} event.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf ActionUrl} is an invalid URL.
 *      \item {\tt DLNA_E_INVALID_DEVICE}: {\bf DevUDN} is an invalid device.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Fun} is not a valid 
 *              callback function or {\bf ServiceType}, {\bf Act}, or 
 *              {\bf ActionUrl} is {\tt NULL}.
 *      \item {\tt DLNA_E_INVALID_ACTION}: This action is not valid.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSendActionExAsync(
    IN dlnaClient_Handle Hnd,   /** The handle of the control point 
                                    sending the action. */
    IN const char *ActionURL,   /** The action URL of the service. */
    IN const char *ServiceType, /** The type of the service. */
    IN const char *DevUDN,      /** This parameter is ignored and must be
				    {\tt NULL}. */
    IN IXML_Document *Header,   /** The DOM document for the SOAP header. 
                                    This may be {\tt NULL} if the header is 
				    not required. */
    IN IXML_Document *Action,   /** The DOM document for the action to 
                                    perform on this device. */
    IN dlna_FunPtr Fun,         /** Pointer to a callback function to 
                                    be invoked when the operation 
				    completes. */
    IN const void *Cookie       /** Pointer to user data that to be 
                                    passed to the callback when invoked. */
    );

/*! @} */ /* Control */

/******************************************************************************
 ******************************************************************************
 *                                                                            *
 *                        E V E N T I N G                                     *
 *                                                                            *
 ******************************************************************************
 ******************************************************************************/

/*! @name Eventing */
/*! @{ */

/** {\bf dlnaAcceptSubscription} accepts a subscription request and sends
 *  out the current state of the eventable variables for a service.  
 *  The device application should call this function when it receives a 
 *  {\tt DLNA_EVENT_SUBSCRIPTION_REQUEST} callback. This function is 
 *  synchronous and generates no callbacks.
 *
 *  {\bf dlnaAcceptSubscription} can be called during the execution of 
 *  a callback function.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *      \item {\tt DLNA_E_INVALID_SERVICE}: The {\bf DevId}/{\bf ServId} 
 *              pair refers to an invalid service. 
 *      \item {\tt DLNA_E_INVALID_SID}: The specified subscription ID is not 
 *              valid.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf VarName}, 
 *              {\bf NewVal}, {\bf DevID}, or {\bf ServID} is not a valid 
 *              pointer or {\bf cVariables} is less than zero.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaAcceptSubscription(
    IN dlnaDevice_Handle Hnd, /** The handle of the device. */
    IN const char *DevID,     /** The device ID of the subdevice of the 
                                  service generating the event. */
    IN const char *ServID,    /** The unique service identifier of the service 
                                  generating the event. */
    IN const char **VarName,  /** Pointer to an array of event variables. */
    IN const char **NewVal,   /** Pointer to an array of values for 
                                  the event variables. */
    IN int cVariables,        /** The number of event variables in 
                                  {\bf VarName}. */
    IN dlna_SID SubsId        /** The subscription ID of the newly 
                                  registered control point. */
    );

/** {\bf dlnaAcceptSubscriptionExt} is similar to {\bf dlnaAcceptSubscription}
 *  except that it takes a DOM document for the variables to event rather
 *  than an array of strings. This function is sychronous
 *  and generates no callbacks.
 *
 *  {\bf dlnaAcceptSubscriptionExt} can be called during the execution of 
 *  a callback function.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *      \item {\tt DLNA_E_INVALID_SERVICE}: The {\bf DevId}/{\bf ServId} 
 *              pair refers to an invalid service. 
 *      \item {\tt DLNA_E_INVALID_SID}: The specified subscription ID is not 
 *              valid.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf VarName},  
 *              {\bf NewVal}, {\bf DevID}, {\bf ServID}, or {\bf PropSet} 
 *              is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaAcceptSubscriptionExt(
    IN dlnaDevice_Handle Hnd,  /** The handle of the device. */
    IN const char *DevID,      /** The device ID of the subdevice of the 
                                   service generating the event. */
    IN const char *ServID,     /** The unique service identifier of the service 
                                   generating the event. */
    IN IXML_Document *PropSet, /** The DOM document for the property set. 
                                   Property set documents must conform to
                                   the XML schema defined in section 4.3 of the
                                   Universal Plug and Play Device Architecture
                                   specification. */
    IN dlna_SID SubsId         /** The subscription ID of the newly 
                                   registered control point. */
    );

/** {\bf dlnaNotify} sends out an event change notification to all
 *  control points subscribed to a particular service.  This function is
 *  synchronous and generates no callbacks.
 *
 *  {\bf dlnaNotify} may be called during a callback function to send out
 *  a notification.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *      \item {\tt DLNA_E_INVALID_SERVICE}: The {\bf DevId}/{\bf ServId} 
 *              pair refers to an invalid service.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf VarName}, {\bf NewVal}, 
 *               {\bf DevID}, or {\bf ServID} is not a valid pointer or 
 *               {\bf cVariables} is less than zero.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaNotify(
    IN dlnaDevice_Handle,   /** The handle to the device sending the event. */
    IN const char *DevID,   /** The device ID of the subdevice of the service 
                                generating the event. */
    IN const char *ServID,  /** The unique identifier of the service 
                                generating the event. */
    IN const char **VarName,/** Pointer to an array of variables that 
                                have changed. */
    IN const char **NewVal, /** Pointer to an array of new values for 
                                those variables. */
    IN int cVariables       /** The count of variables included in this 
                                notification. */
    );

/** {\bf dlnaNotifyExt} is similar to {\bf dlnaNotify} except that it takes
 *  a DOM document for the event rather than an array of strings. This 
 *  function is synchronous and generates no callbacks.
 *
 *  {\bf dlnaNotifyExt} may be called during a callback function to send out
 *  a notification.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *      \item {\tt DLNA_E_INVALID_SERVICE}: The {\bf DevId}/{\bf ServId} 
 *              pair refers to an invalid service.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf VarName}, {\bf NewVal}, 
 *               {\bf DevID}, {\bf ServID}, or {\bf PropSet} 
 *               is not a valid pointer or {\bf cVariables} is less than zero.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaNotifyExt(
    IN dlnaDevice_Handle,       /** The handle to the device sending the 
                                    event. */
    IN const char *DevID,       /** The device ID of the subdevice of the 
                                    service generating the event. */
    IN const char *ServID,      /** The unique identifier of the service 
                                    generating the event. */
    IN IXML_Document *PropSet   /** The DOM document for the property set. 
                                    Property set documents must conform to 
                                    the XML schema defined in section 4.3 of 
                                    the Universal Plug and Play Device 
                                    Architecture specification. */
    );

/** {\bf dlnaRenewSubscription} renews a subscription that is about to 
 *  expire.  This function is synchronous.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf Timeout} is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_SID}: The SID being passed to this function 
 *              is not a valid subscription ID.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured. 
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.  
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl}.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error occurred creating a socket.
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher.
 *      \item {\tt DLNA_E_SUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the subscription renew.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaRenewSubscription(
    IN dlnaClient_Handle Hnd, /** The handle of the control point that 
                                  is renewing the subscription. */
    INOUT int *TimeOut,       /** Pointer to a variable containing the 
                                  requested subscription time.  Upon return, 
                                  it contains the actual renewal time. */
    IN dlna_SID SubsId        /** The ID for the subscription to renew. */
    );

/** {\bf dlnaRenewSubscriptionAsync} renews a subscription that is about
 *  to expire, generating a callback when the operation is complete.
 *
 *  Note that many of the error codes for this function are returned in
 *  the {\bf dlna_Event_Subscribe} structure.  In those cases, the function
 *  returns {\tt DLNA_E_SUCCESS} and the appropriate error code will
 *  be in the {\bf dlna_Event_Subscribe.ErrCode} field in the {\bf Event}
 *  structure passed to the callback.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_SID}: The {\bf SubsId} is not a valid 
 *              subscription ID.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf Fun} is not a valid 
 *              callback function pointer or {\bf Timeout} is less than zero 
 *              but is not {\tt DLNA_INFINITE}.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured (returned in 
 *              the {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket (returned in the {\bf dlna_Event_Subscribe.ErrCode} 
 *              field as part of the callback).
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading  
 *              from a socket (returned in the 
 *              {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding the socket 
 *              (returned in the {\bf dlna_Event_Subscribe.ErrCode} field as 
 *              part of the callback).
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl} (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error occurred creating socket (
 *              returned in the {\bf dlna_Event_Subscribe.ErrCode} field as 
 *              part of the callback).
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_SUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the subscription request (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaRenewSubscriptionAsync(
    IN dlnaClient_Handle Hnd, /** The handle of the control point that 
                                  is renewing the subscription. */
    IN int TimeOut,           /** The requested subscription time.  The 
                                  actual timeout value is returned when 
                                  the callback function is called. */
    IN dlna_SID SubsId,       /** The ID for the subscription to renew. */
    IN dlna_FunPtr Fun,       /** Pointer to a callback function to be 
                                  invoked when the renewal is complete. */
    IN const void *Cookie     /** Pointer to user data passed 
                                  to the callback function when invoked. */
    );

/** {\bf dlnaSetMaxSubscriptions} sets the maximum number of subscriptions 
 *  accepted per service. The default value accepts as many as system 
 *  resources allow. If the number of current subscriptions for a service is 
 *  greater than the requested value, the SDK accepts no new 
 *  subscriptions or renewals, however, the SDK does not remove
 *  any current subscriptions.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSetMaxSubscriptions(  
    IN dlnaDevice_Handle Hnd, /** The handle of the device for which 
				  the maximum number of subscriptions is 
				  being set. */
    IN int MaxSubscriptions   /** The maximum number of subscriptions to be 
				  allowed per service. */
    );

/** {\bf dlnaSetMaxSubscriptionTimeOut} sets the maximum time-out accepted
 *  for a subscription request or renewal. The default value accepts the 
 *  time-out set by the control point. If a control point requests a 
 *  subscription time-out less than or equal to the maximum, the SDK
 *  grants the value requested by the control point.  If the time-out 
 *  is greater, the SDK returns the maximum value.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid device 
 *              handle.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSetMaxSubscriptionTimeOut(  
    IN dlnaDevice_Handle Hnd,       /** The handle of the device for which 
				        the maximum subscription time-out is 
                                        being set. */
    IN int MaxSubscriptionTimeOut   /** The maximum subscription time-out to 
                                        be accepted. */
    );

/** {\bf dlnaSubscribe} registers a control point to receive event
 *  notifications from another device.  This operation is synchronous.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: {\bf PublisherUrl} is not a valid URL.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf Timeout} is not a valid pointer 
 *              or {\bf SubsId} or {\bf PublisherUrl} is {\tt NULL}.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured. 
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl}.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error occurred creating a socket.
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher.
 *      \item {\tt DLNA_E_SUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the subscription request.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSubscribe(
    IN dlnaClient_Handle Hnd,    /** The handle of the control point. */
    IN const char *PublisherUrl, /** The URL of the service to subscribe to. */
    INOUT int *TimeOut,          /** Pointer to a variable containing 
                                     the requested subscription time.  Upon 
                                     return, it contains the actual 
                                     subscription time returned from the 
                                     service. */
    OUT dlna_SID SubsId          /** Pointer to a variable to receive the 
                                     subscription ID (SID). */
    );

/** {\bf dlnaSubscribeAsync} performs the same operation as
 *  {\bf dlnaSubscribe}, but returns immediately and calls the registered
 *  callback function when the operation is complete.
 *
 *  Note that many of the error codes for this function are returned in
 *  the {\bf dlna_Event_Subscribe} structure.  In those cases, the function
 *  returns {\tt DLNA_E_SUCCESS} and the appropriate error code will
 *  be in the {\bf dlna_Event_Subscribe.ErrCode} field in the {\bf Event}
 *  structure passed to the callback.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf PublisherUrl} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf TimeOut} or {\bf Fun} or 
 *              {\bf PublisherUrl} is not a valid pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured (returned in 
 *              the {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket (returned in the 
 *              {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket (returned in the 
 *              {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding the socket 
 *              (returned in the {\bf dlna_Event_Subscribe.ErrCode} field as 
 *              part of the callback).
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl} (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error occurred creating  the 
 *              socket (returned in the {\bf dlna_Event_Subscribe.ErrCode} 
 *              field as part of the callback).
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_SUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the subscription request (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSubscribeAsync(
    IN dlnaClient_Handle Hnd,      /** The handle of the control point that 
                                       is subscribing. */
    IN const char *PublisherUrl,   /** The URL of the service to subscribe 
                                       to. */
    IN int TimeOut,                /** The requested subscription time.  Upon 
                                       return, it contains the actual 
                                       subscription time returned from the 
                                       service. */
    IN dlna_FunPtr Fun,            /** Pointer to the callback function for 
                                       this subscribe request. */
    IN const void *Cookie          /** A user data value passed to the 
                                       callback function when invoked. */
    );

/** {\bf dlnaUnSubscribe} removes the subscription of  a control point from a 
 *  service previously subscribed to using {\bf dlnaSubscribe} or 
 *  {\bf dlnaSubscribeAsync}.  This is a synchronous call.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_SID}: The {\bf SubsId} is not a valid 
 *              subscription ID.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured. 
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl}.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error ocurred creating a socket.
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher.
 *      \item {\tt DLNA_E_UNSUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the unsubscribe request (the client is still unsubscribed and 
 *              no longer receives events).
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaUnSubscribe(
    IN dlnaClient_Handle Hnd, /** The handle of the subscribed control 
                                  point. */
    IN dlna_SID SubsId        /** The ID returned when the control point 
                                  subscribed to the service. */
    );

/** {\bf dlnaUnSubscribeAsync} removes a subscription of a control
 *  point from a service previously subscribed to using {\bf
 *  dlnaSubscribe} or {\bf dlnaSubscribeAsync}, generating a callback
 *  when the operation is complete.
 *
 *  Note that many of the error codes for this function are returned in
 *  the {\bf dlna_Event_Subscribe} structure.  In those cases, the function
 *  returns {\tt DLNA_E_SUCCESS} and the appropriate error code will
 *  be in the {\bf dlna_Event_Subscribe.ErrCode} field in the {\bf Event}
 *  structure passed to the callback.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_HANDLE}: The handle is not a valid control 
 *              point handle.
 *      \item {\tt DLNA_E_INVALID_SID}: The {\bf SubsId} is not a valid SID.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf Fun} is not a valid callback 
 *              function pointer.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              complete this operation.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occured (returned in 
 *              the {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket (returned in the 
 *              {\bf dlna_Event_Subscribe.ErrCode} field as part of the 
 *              callback).
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding the socket 
 *              (returned in the {\bf dlna_Event_Subscribe.ErrCode} field as 
 *              part of the callback).
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting to 
 *              {\bf PublisherUrl} (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: An error occurred creating a socket (
 *              returned in the {\bf dlna_Event_Subscribe.ErrCode} field as 
 *              part of the callback).
 *      \item {\tt DLNA_E_BAD_RESPONSE}: An error occurred in response from 
 *              the publisher (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *      \item {\tt DLNA_E_UNSUBSCRIBE_UNACCEPTED}: The publisher refused 
 *              the subscription request (returned in the {\bf 
 *              dlna_Event_Subscribe.ErrCode} field as part of the callback).
 *    \end{itemize} */

EXPORT_SPEC int dlnaUnSubscribeAsync(
    IN dlnaClient_Handle Hnd, /** The handle of the subscribed control 
                                  point. */
    IN dlna_SID SubsId,       /** The ID returned when the 
                                  control point subscribed to the service. */
    IN dlna_FunPtr Fun,       /** Pointer to a callback function to be 
                                  called when the operation is complete. */
    IN const void *Cookie     /** Pointer to user data to pass to the 
                                  callback function when invoked. */
    );

/*! @} */ /* Eventing */


/******************************************************************************
 ******************************************************************************
 *                                                                            *
 *                        C L I E N T - A P I                                 *
 *                                                                            *
 ******************************************************************************
 ******************************************************************************/

/*! @name Control Point HTTP API */
/*! @{ */

/** {\bf dlnaDownloadUrlItem} downloads a file specified in a URL.
 *  The SDK allocates the memory for {\bf outBuf} and the 
 *  application is responsible for freeing this memory.  Note that
 *  the item is passed as a single buffer.  Large items should not
 *  be transferred using this function.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url}, {\bf outBuf} 
 *              or {\bf contentType} is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              download this file.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting a 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaDownloadUrlItem(
    IN const char *url,          /** URL of an item to download. */
    OUT char **outBuf,           /** Buffer to store the downloaded item. */
    OUT char *contentType        /** HTTP header value content type if 
                                     present. It should be at least 
                                     {\tt LINE_SIZE} bytes in size. */
    );

/** {\bf dlnaOpenHttpGet} gets a file specified in a URL.
 *  The SDK allocates the memory for {\bf handle} and 
 *  {\bf contentType}, the application is responsible for freeing this memory.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url}, {\bf handle},  
 *              {\bf contentType}, {\bf contentLength} or {\bf httpStatus} 
 *		is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              download this file.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting a 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *	\item {\tt DLNA_E_BAD_RESPONSE}: A bad response was received from the 
 *	        remote server.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaOpenHttpGet(
	IN const char *url,	    /** The URL of an item to get. */
	IN OUT void **handle,       /** A pointer to store the handle for 
				        this connection. */
	IN OUT char **contentType,  /** A buffer to store the media type of 
				        the item. */
	IN OUT int *contentLength,  /** A pointer to store the length of the 
				        item. */
	IN OUT int *httpStatus,	    /** The status returned on receiving a 
				        response message. */
	IN int timeout		    /** The time out value sent with the 
				        request during which a response is 
					expected from the server, failing 
					which, an error is reported back to 
					the user. */		 
	  );

/** {\bf dlnaOpenHttpGetProxy} gets a file specified in a URL through the
 * specified proxy.
 *  The SDK allocates the memory for {\bf handle} and 
 *  {\bf contentType}, the application is responsible for freeing this memory.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url}, {\bf handle},  
 *              {\bf contentType}, {\bf contentLength} or {\bf httpStatus} 
 *		is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              download this file.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting a 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *	\item {\tt DLNA_E_BAD_RESPONSE}: A bad response was received from the 
 *	        remote server.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaOpenHttpGetProxy(
	IN const char *url,	    /** The URL of an item to get. */
    IN const char *proxy_str,    /** The URL of the proxy. */
	IN OUT void **handle,       /** A pointer to store the handle for 
				        this connection. */
	IN OUT char **contentType,  /** A buffer to store the media type of 
				        the item. */
	IN OUT int *contentLength,  /** A pointer to store the length of the 
				        item. */
	IN OUT int *httpStatus,	    /** The status returned on receiving a 
				        response message. */
	IN int timeout		    /** The time out value sent with the 
				        request during which a response is 
					expected from the server, failing 
					which, an error is reported back to 
					the user. */		 
	  );

/** {\bf dlnaOpenHttpGetEx} gets specified number of bytes from a file 
 *  specified in the URL. The number of bytes is specified through a low 
 *  count and a high count which are passed as a range of bytes for the 
 *  request.  The SDK allocates the memory for {\bf handle} and 
 *  {\bf contentType}, the application is responsible for freeing this memory.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url}, {\bf handle},  
 *              {\bf contentType}, {\bf contentLength} or {\bf httpStatus} 
 *		is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              download this file.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting a 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *	\item {\tt DLNA_E_BAD_RESPONSE}: A bad response was received from the 
 *	        remote server.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaOpenHttpGetEx(
	IN const char *url,         /** The URL of the item to get. */
	IN OUT void **handle,       /** A pointer to store the handle for 
				        this connection. */
	IN OUT char **contentType,  /** A buffer to store the media type of the 
	                                item. */
	IN OUT int *contentLength,  /** A buffer to store the length of the 
				        item. */
	IN OUT int *httpStatus,	    /** The status returned on receiving a 
				        response message from the remote 
					server. */
	IN int lowRange,            /** An integer value representing the low 
				        end of a range to retrieve. */
	IN int highRange,           /** An integer value representing the high 
				        end of a range to retrieve. */
	IN int timeout	            /** A time out value sent with the request 
				      	during which a response is expected 
					from the server, failing which, an 
					error is reported back to the user. */	
	  );

/** {\bf dlnaReadHttpGet} gets specified number of bytes from a file 
 *  specified in a URL. 
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf handle}, {\bf buf} 
 *              or {\bf size} is not a valid pointer.
 *	    \item {\tt DLNA_E_BAD_RESPONSE}: A bad response was received from the 
 *	            remote server.
 *      \item {\tt DLNA_E_BAD_HTTPMSG}: Either the request or response was in 
 *              the incorrect format.
 *      \item {\tt DLNA_E_CANCELED}: another thread called dlnaCancelHttpGet.
 *    \end{itemize}
 *
 *  Note: In case of return values, the status code parameter of the passed 
 *        in handle value may provide additional information on the return 
 *        value.
 */

EXPORT_SPEC int dlnaReadHttpGet(
	IN void *handle,           /** The token created by the call to 
				       {\bf dlnaOpenHttpGet}. */
	IN OUT char *buf,          /** The buffer to store the read item. */
	IN OUT unsigned int *size, /** The size of the buffer to be read. */
	IN int timeout             /** The time out value sent with the 
				       request during which a response is 
				       expected from the server, failing 
				       which, an error is reported back to 
				       the user. */
	);

/** {\bf dlnaHttpGetProgress} rettrieve progress information of a http-get 
 *  transfer. 
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf handle}, {\bf length} 
 *              or {\bf total} is not a valid pointer.
 *    \end{itemize}
 *
 */
EXPORT_SPEC int dlnaHttpGetProgress(
    IN void *handle,           /** The token created by the call to
				       {\bf dlnaOpenHttpGet}. */
	OUT unsigned int *length, /** The number of bytes received. */
	OUT unsigned int *total   /** The content length. */
    );


/** {\bf dlnaCancelHttpGet} set the cancel flag of the  {\bf handle}
 * parameter. 
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf handle} is not a valid pointer.
 *    \end{itemize}
 */  

EXPORT_SPEC int dlnaCancelHttpGet(IN void *handle);

/** {\bf dlnaCloseHttpGet} closes the connection and frees memory that was 
 *	allocated for the {\bf handle} parameter.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: {\bf handle} is not a valid pointer.
 *    \end{itemize}
 */  

EXPORT_SPEC int dlnaCloseHttpGet(IN void *handle);


/** {\bf dlnaOpenHttpPost} makes an HTTP POST request message, opens a 
 *  connection to the server and sends the POST request to the server if 
 *  the connection to the server succeeds.
 *  The SDK allocates the memory for {\bf handle} and 
 *  {\bf contentType}, the application is responsible for freeing this memory.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url}, {\bf handle} 
 *              or {\bf contentType} is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: Insufficient resources exist to 
 *              download this file.
 *      \item {\tt DLNA_E_SOCKET_ERROR}: Error occured allocating a socket and 
 *		resources or an error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting a 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaOpenHttpPost(
	IN const char *url,         /** The URL in which to send the POST 
				        request. */
	IN OUT void **handle,	    /** A pointer in which to store the 
	                                handle for this connection.  This 
					handle is required for futher 
					operations over this connection. */
	IN const char *contentType, /** A buffer to store the media type of 
				        content being sent.  */
	IN int contentLength,       /** The length of the content, in bytes, 
				        being posted. */
	IN int timeout              /** The time out value sent with the 
				        request during which a response is 
					expected from the receiver, failing 
					which, an error is reported. */		 
	);


/** {\bf dlnaWriteHttpPost} sends a request to a server to copy the contents of 
 *	a buffer to the URI specified in the {\bf dlnaOpenHttpPost} call.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf handle}, {\bf buf} 
 *              or {\bf size} is not a valid pointer.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaWriteHttpPost(
	IN void *handle,          /** The handle of the connection created 
				      by the call to {\bf dlnaOpenHttpPost}. */
	IN char *buf,             /** The buffer to be posted. */
	IN unsigned int *size,    /** The size, in bytes of {\bf buf}. */
	IN int timeout            /** A timeout value sent with the request 
				      during which a response is expected 
				      from the server, failing which, an 
				      error is reported. */		 
	);

/** {\bf dlnaCloseHttpPost} sends and receives any pending data, closes the 
 *	connection with the server, and frees memory allocated during the 
 *	{\bfdlnaOpenHttpPost} call.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf handle}, or 
 *				{\bf httpStatus} is not a valid pointer.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *    \end{itemize}
 */
  
EXPORT_SPEC int dlnaCloseHttpPost(
	IN void *handle,          /** The handle of the connection to close, 
				      created by the call to 
				      {\bf dlnaOpenHttpPost}. */
	IN OUT int *httpStatus,   /** A pointer to a buffer to store the 
	                              final status of the connection. */
	IN int timeout            /** A time out value sent with the request 
				      during which a response is expected from 
				      the server, failing which, an error is 
				      reported. */		 
	);
  

/** {\bf dlnaDownloadXmlDoc} downloads an XML document specified in a URL.
 *  The SDK parses the document and returns it in the form of a 
 *  DOM document. The application is responsible for freeing the DOM document.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *      \item {\tt DLNA_E_SUCCESS}: The operation completed successfully.
 *      \item {\tt DLNA_E_INVALID_PARAM}: Either {\bf url} or {\bf xmlDoc} 
 *              is not a valid pointer.
 *      \item {\tt DLNA_E_INVALID_DESC}: The XML document was not 
 *              found or it does not contain a valid XML description.
 *      \item {\tt DLNA_E_INVALID_URL}: The {\bf url} is not a valid 
 *              URL.
 *      \item {\tt DLNA_E_OUTOF_MEMORY}: There are insufficient resources to 
 *              download the XML document.
 *      \item {\tt DLNA_E_NETWORK_ERROR}: A network error occurred.
 *      \item {\tt DLNA_E_SOCKET_WRITE}: An error or timeout occurred writing 
 *              to a socket.
 *      \item {\tt DLNA_E_SOCKET_READ}: An error or timeout occurred reading 
 *              from a socket.
 *      \item {\tt DLNA_E_SOCKET_BIND}: An error occurred binding a socket.
 *      \item {\tt DLNA_E_SOCKET_CONNECT}: An error occurred connecting the 
 *              socket.
 *      \item {\tt DLNA_E_OUTOF_SOCKET}: Too many sockets are currently 
 *              allocated.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaDownloadXmlDoc(
    IN const char *url,          /** URL of the XML document. */
    OUT IXML_Document **xmlDoc   /** A pointer in which to store the 
				     XML document. */
    );

/*! @} */ /* Control Point HTTP API */

/******************************************************************************
 ******************************************************************************
 *                                                                            *
 *                    W E B  S E R V E R  A P I                               *
 *                                                                            *
 ******************************************************************************
 ******************************************************************************/

/*! @name Web Server API */
/*! @{ */

/** {\bf dlnaSetWebServerRootDir} sets the document root directory for
 *  the internal web server. This directory is considered the
 *  root directory (i.e. "/") of the web server.
 *
 *  This function also activates or deactivates the web server.
 *  To disable the web server, pass {\tt NULL} for {\bf rootDir}; to 
 *  activate, pass a valid directory string.
 *  
 *  Note that this function is not available when the web server is not
 *  compiled into the SDK.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
 *       \item {\tt DLNA_E_INVALID_ARGUMENT}: {\bf rootDir} is an invalid 
 *               directory.
 *    \end{itemize}
 */
 
EXPORT_SPEC int dlnaSetWebServerRootDir( 
    IN const char* rootDir  /** Path of the root directory of the web 
                                server. */
    );

/** {\bf dlnaSetVirtualDirCallbacks} sets the callback function to be used to 
 *  access a virtual directory.  Refer to the description of
 *  {\bf dlnaVirtualDirCallbacks} for a description of the functions.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
 *       \item {\tt DLNA_E_INVALID_ARGUMENT}: {\bf callbacks} is not a valid 
 *               pointer.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaSetVirtualDirCallbacks(
    IN struct dlnaVirtualDirCallbacks *callbacks, /** Pointer to a structure 
                                                     containing points to the 
                                                     virtual interface 
                                                     functions. */
    IN void *cookie);

/** {\bf dlnaEnableWebServer} enables or disables the webserver.  A value of
 *  {\tt TRUE} enables the webserver, {\tt FALSE} disables it.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
 *       \item {\tt DLNA_E_INVALID_ARGUMENT}: {\bf enable} is not valid.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaEnableWebserver(
    IN int enable /** {\tt TRUE} to enable, {\tt FALSE} to disable. */
    );

/** {\bf dlnaIsWebServerEnabled} returns {\tt TRUE} if the webserver is
 *  enabled, or {\tt FALSE} if it is not.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt TRUE}: The webserver is enabled.
 *       \item {\tt FALSE}: The webserver is not enabled
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaIsWebserverEnabled();

/** {\bf dlnaAddVirtualDir} adds a virtual directory mapping.
 *
 *  All webserver requests containing the given directory are read using
 *  functions contained in a {\bf dlnaVirtualDirCallbacks} structure registered
 *  via {\bf dlnaSetVirtualDirCallbacks}.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
 *       \item {\tt DLNA_E_INVALID_ARGUMENT}: {\bf dirName} is not valid.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaAddVirtualDir(
    IN const char *dirName /** The name of the new directory mapping to add. 
							*/
    );

/** {\bf dlnaRemoveVirtualDir} removes a virtual directory mapping made with
 *  {\bf dlnaAddVirtualDir}.
 *
 *  @return [int] An integer representing one of the following:
 *    \begin{itemize}
 *       \item {\tt UPPN_E_SUCCESS}: The operation completed successfully.
 *       \item {\tt DLNA_E_INVALID_ARGUMENT}: {\bf dirName} is not valid.
 *    \end{itemize}
 */

EXPORT_SPEC int dlnaRemoveVirtualDir(
    IN const char *dirName /** The name of the virtual directory mapping to 
                               remove. */
    );

/** {\bf dlnaRemoveAllVirtualDirs} removes all virtual directory mappings.
 *
 *  @return [void] This function does not return a value.
 *
 */

EXPORT_SPEC void dlnaRemoveAllVirtualDirs( );

EXPORT_SPEC void dlnaFree(
    IN void *item /* The item to free. */
    );

/*! @} */ /* Web Server API */

#ifdef __cplusplus
}
#endif /* __cplusplus */

/*! @} */ /* The API */

#endif

